---
AWSTemplateFormatVersion: '2010-09-09'
Parameters:

  Environment:
    Type: String
    Description: 'environment variable'
    Default: dev

  FunctionName:
    Type: String
    Description: 'Name of Lambda'
    Default: SESBounceNotificationsLambda

  SNSTopicName:
    Type: String
    Description: 'Name of SNS Topic'
    Default: SNSBounceNotificationsLambda


  DBHost:
    Type: String
    Description: 'DB Host'
    Default: xx

  DBUser:
    Type: String
    Description: 'DB user'
    Default: xx

  DBPass:
    Type: String
    Description: 'DB pass'
    NoEcho: True

  DBPort:
    Type: String
    Description: 'DB port'
    Default: 3306

  DBDatabase:
    Type: String
    Description: 'DB database'
    Default: xx

  DBTimeout:
    Type: String
    Description: 'DB timeout'
    Default: 15

Mappings:

  Environments:
    dev:
      VPC: vpc-xxx
      Subnets:
        - subnet-xxx
        - subnet-xxx
        - subnet-xxx
      DBSecurityGroups:
        - sg-xxx
        - sg-xxx

Resources:

  LambdaSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
        GroupDescription: Allow lambda outbound ports
        VpcId: !FindInMap [Environments, !Ref Environment, VPC]
        SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0

  SNSTopic:
    Type: AWS::SNS::Topic
    Properties: 
      DisplayName: !Ref SNSTopicName
      TopicName: !Ref SNSTopicName

  SNSSubscription:
    DependsOn:
      - LambdaFunction
    Type: 'AWS::SNS::Subscription'
    Properties:
      Endpoint: !GetAtt LambdaFunction.Arn
      Protocol: lambda
      TopicArn: !Ref SNSTopic

  LambdaFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"

  LambdaRolePolicies:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: LambdaPolicy
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: cloudwatch
          Action:
          - logs:CreateLogGroup
          - logs:CreateLogStream
          - logs:PutLogEvents
          - logs:GetLogEvents
          Effect: Allow
          Resource: arn:aws:logs:*:*:*
        - Sid: lambdavpc
          Action:
            - ec2:CreateNetworkInterface
            - ec2:DescribeNetworkInterfaces
            - ec2:DeleteNetworkInterface
            - ec2:DescribeSeccurityGroups
            - ec2:DescribeSubnets
            - ec2:DescribeVpcs
          Effect: Allow
          Resource: '*'
      Roles:
        - !Ref LambdaFunctionRole


  LambdaFunction:
    DependsOn:
      - LambdaRolePolicies
    Type: AWS::Lambda::Function
    Properties:
      Description: 'Lambda for SES notification parsing'
      Handler: index.handler
      Role: !GetAtt LambdaFunctionRole.Arn
      FunctionName: !Ref FunctionName
      Code:
        ZipFile:
          Fn::Sub: |
            import boto3
            import json
            import re
            import logging
            import os
            import sys
            import pymysql

            # Setting up logging
            logger = logging.getLogger()
            logger.setLevel(logging.DEBUG)
            # main function
            def handler(event, context):

              emails = []
              addemails = []
              #excluded email
              exemail = ['example@email.org', 'example2@email.org', '@email.org]
              #set default blacklist to True
              blacklist = True

              try:
                message = event['Records'][0]['Sns']['Message']
                messagejson = json.loads(message)
                bouncetype = str(messagejson['bounce']['bounceType'])
                logger.debug(f"Bounce Type: {bouncetype}")
                if(bouncetype == "Permanent"):
                  logger.info(f"Bounce Type is Permanent, adding to blacklist.")
                  blacklist = True
                if(bouncetype == "Transient"):
                  logger.info(f"Bounce Type is Transient, ignoring.")
                  blacklist = False
                if(bouncetype == "Undetermined"):
                  logger.info(f"Bounce Type is Undetermined, ignoring.")
                  blacklist = False
              except:
                logger.debug(f"Did not retrieve bounce type")

              try:
                message = event['Records'][0]['Sns']['Message']
                messagejson = json.loads(message)
                complainttype = str(messagejson['complaint']['complaintFeedbackType'])
                logger.debug(f"Complaint Type: {complainttype}")
                if complainttype:
                  logger.info(f"Complaint Type is {complainttype}, adding to blacklist.")
                  blacklist = True
              except:
                logger.debug(f"Did not complaint bounce type")    

              if blacklist:

                logger.debug(f"Blacklist is true, beginning parsing")

                try:
                  event = str(event)
                  logger.debug(f"Event: {event}")
                  eventemails = re.findall("([a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+)", event)
                  if eventemails:
                    for eventemail in eventemails:
                      logger.debug(f"Event Email: {eventemail}")
                      eventemail = str(eventemail)
                      eventemail = eventemail.replace("['", "")
                      eventemail = eventemail.replace("']", "")
                      logger.debug(f"Event Formatted Email: {eventemail}")
                      emails.append(eventemail)
                except:
                  logger.error(f"Event emails not found")

                #remove duplicates
                emails = set(emails)
                #remove excluded emails and domains
                logger.debug(f"Emails after remove duplicates: {emails}")
                checkemails = emails.copy()
                for email in checkemails:
                  logger.debug(f"Inspecting: {email}")
                  for exclude in exemail:
                    logger.debug(f"Comparing: {exclude} to {email}")
                    if str(exclude) in str(email):
                      logger.debug(f"Removing excluded email: {email}")
                      try:
                        emails.remove(email)
                      except:
                        logger.error(f"Could not remove email {email}")
                      else:
                        logger.debug(f"Removed {email} from list due to exclusion")
                        break
                logger.debug(f"Event emails found: {str(emails)}")

                try:
                  con = pymysql.connect(
                    host="${DBHost}",
                    user="${DBUser}", 
                    password="${DBPass}",
                    database="${DBDatabase}",
                    port=${DBPort},
                    connect_timeout=${DBTimeout}
                  )
                  logger.debug(f"Connection: {con}")
                  cur = con.cursor()
                except pymysql.MySQLError as e:
                  logger.error("ERROR: Unexpected error: Could not connect to MySQL instance.")
                  logger.error(e)
                  sys.exit()

                for email in emails:
                  try:
                    logger.debug(f"Checking if email: {email} already exists in blacklist...")
                    selquery='SELECT * FROM email_blacklist WHERE email=%s;'
                    cur.execute(selquery, email)
                    checkrow = cur.fetchone()
                    if checkrow == None:
                      logger.info(f"{email} not found, adding")
                      addemails.append(email)
                    else:
                      logger.info(f"{email} already exists, skipping!")
                  except:
                    logger.error(f"Unable to perform lookup in database for {email}")

                for addemail in addemails:
                  try:
                    logger.info(f'Adding to email {addemail} to database')
                    addquery='INSERT INTO email_blacklist (email, blocked) VALUES (%s, 1);'
                    cur.execute(addquery, addemail)
                    con.commit()
                  except:
                    logger.error(f"Failed to add {addemail} to blacklist")
                  else:
                    logger.info(f"Successfully added {addemail} to blacklist")

                try:
                  con.close()
                except:
                  logger.error(f"Error closing connection to database")
                else:
                  logger.debug(f"Closed database connection")
              
              else:
                logger.debug(f"Blacklist is false, ignoring...")
      Runtime: python3.8
      Timeout: '60'
      VpcConfig:
        SubnetIds: !FindInMap [Environments, !Ref Environment, Subnets]
        SecurityGroupIds:
          - !Ref LambdaSG

  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt LambdaFunction.Arn
      Action: lambda:InvokeFunction
      Principal: sns.amazonaws.com
      SourceArn: !Ref SNSTopic
